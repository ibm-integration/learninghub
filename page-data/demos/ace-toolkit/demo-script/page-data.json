{"componentChunkName":"component---src-pages-demos-ace-toolkit-demo-script-mdx","path":"/demos/ace-toolkit/demo-script/","result":{"pageContext":{"frontmatter":{"title":"ACE Toolkit Demo","description":"ACE Toolkit Demo for TechSales","tabs":["Demo preparation","Demo script"]},"relativePagePath":"/demos/ace-toolkit/demo-script.mdx","titleType":"page","MdxNode":{"id":"4b06d539-be84-5998-af68-a856d3e3e432","children":[],"parent":"370bc9e6-2143-57a3-9cb9-5ad40554e802","internal":{"content":"---\r\ntitle: ACE Toolkit Demo\r\ndescription: ACE Toolkit Demo for TechSales\r\ntabs: [ 'Demo preparation', 'Demo script']\r\n---\r\n\r\n\r\n<FeatureCard\r\n  title=\"Create integrations with App Connect for Developers Toolkit - Demo Script\"\r\n  color=\"dark\"\r\n  >\r\n\r\n![banner](./images/banner-ace-toolkit.jpg)\r\n\r\n</FeatureCard>\r\n\r\n\r\n<span id=\"place1\"></span>\r\n\r\n### **Introduction**\r\n<br/>\r\nToday's organizations use a wide variety of diverse Software as a Service (SaaS) applications, often without centralized coordination between them. However, integrating applications  is essential to help organizations increase efficiency and optimize business workflows. For instance, in a typical sales process without application integration, sales reps may use Salesforce for customer relationships and Excel for quotes. After finalizing a sale, they must manually transfer data such as customer details, product information, and pricing data from Salesforce to Excel. This can be time-consuming and prone to errors, leading to delays in processing sales orders and potential inaccuracies in pricing.\r\n<br/><br/>\r\nBy connecting your apps using IBM App Connect, the process becomes more streamlined, accurate and efficient because reps can automate data input to create quotes directly from their CPQ application with centralized tracking.\r\n<br/><br/>\r\nIBM App Connect can help you securely connect all your endpoints, from databases to packaged apps. It provides  an out-of-the-box set of capabilities that will accelerate  SaaS integration and automation across your business. Additionally, the development kit allows citizen integrators to understand and build powerful integrations with little to no training.\r\n<br/><br/>\r\nFocus Corporation, a hypothetical retail company engaged with IBM, is highly motivated to derive more revenue from first-time customers to their online storefronts. Focus has acquired another business and needs to integrate the different IT applications.\r\n<br/><br/>\r\nThe Focus Integration expert would like to build complex, multi-style integrations with support for multiple programming languages and fully integrated with source and pipeline management tools like GIT, Maven, Jenkins, etc. \r\n<br/><br/>\r\nThe Focus team requested a demo to learn how IBM App Connect for Developers Toolkit can help them to implement complex and advanced integration scenarios.\r\n<br/><br/>\r\n\r\n\r\n### **1. Create your Integration flow**\r\n\r\n<details>\r\n<summary>1.1. Starting App Connect Toolkit</summary><br/>\r\n\r\n**Narration**\r\n\r\nIBM App Connect is an industry-leading integration solution that connects any of your applications and data, no matter where they reside. With hundreds of prebuilt connectors and customizable templates, App Connect helps users of all skill levels rapidly connect Software as a Service (SaaS) applications and build integration flows.\r\n\r\nThe Focus team is looking for an advanced, fully customizable code platform. They would like to harness a lightweight, fast-performing engine that easily scales to support their growing needs. They need to enable support for multiple types of data integration, including event, application programming interfaces (APIs), services, sync/async, transactional batch processing and more. Focus Integration experts need to map data fields and transform data formats exchanged between applications, such as XML, JSON, CSV, EDIFACT, SWIFT and other industry protocols.\r\n\r\nBecause of that, they decided to explore IBM App Connect Enterprise for Developers (Toolkit). The Toolkit is an integrated development environment and graphical user interface based on the Eclipse platform. Focus Integration experts can use the IBM App Connect Enterprise Toolkit to build powerful integration applications, services, and APIs. And they can then deploy their integration solutions to the software run time, IBM App Connect Enterprise as a Service, containers, or a combination of those environments.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.1.1.\r\n\r\nOpen your **App Connect Enterprise Toolkit** by clicking the icon on the Launchpad (MAC OS) or Desktop (Windows) or executing **ace toolkit** in terminal window.\r\n\r\n  ![](images/start-toolkit-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.1.2.\r\n\r\nIn the Workspace Launcher window, accept the default one. Click **Launch**.\r\n\r\n  ![](images/start-toolkit-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.1.3.\r\n\r\n**Close** the *welcome page*.\r\n\r\n  ![](images/start-toolkit-3.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>1.2. Creating a REST API</summary><br/>\r\n\r\n**Narration**\r\n\r\nFrom the Integration Development perspective, Focus Integration experts can create all manner of integration flows, as well as manage connectivity between services and endpoints.\r\n\r\nThe Focus team would like to explore how easy is to create an API flow that implements different types of message transformation.\r\n\r\nApp Connect provides a specific type of project to support REST API implementations, which can either be based upon a Swagger (v2) specification document or an OpenAPI (v3) specification document. REST APIs can be authored and deployed from the IBM App Connect Enterprise Toolkit.\r\n\r\nLet's see how easy is to create a REST API using the Toolkit. The Focus team will create a REST API from an existing OpenAPI v3 document.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.2.1.\r\n\r\nFrom the Application Development view click the **New...** hyperlink at the top right (A) and from the menu which appears, click on **REST API** (B).\r\n\r\n  ![](images/create-rest-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.2.\r\n\r\nType the Name **ShoppingListAPI** (A) and switch the radio button to the option labelled “**Import resources and operations defined in a REST API document**\" (B) then click **Next** (C).\r\n\r\n  ![](images/create-rest-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.3.\r\n\r\nYou will be asked to import an OpenAPI 3 document either from the file system or your workspace. Using the radio button to “**Select from your workspace**” (A), select **ShoppingListAPI.json** from the json folder in the **HelperFiles** project (B) (note: if you don't see the HelperFiles project, maybe you forgot to import this project in the Demo Preparation part). Click **Next** (C).\r\n\r\n  ![](images/create-rest-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.4.\r\n\r\nClick **Finish**.\r\n\r\n  ![](images/create-rest-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>1.3. Exploring the REST API details</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Focus team created the REST API and they can see a summary page displaying details about the API such as its title and base URL. The next section down entitled Resources and Operations lists the operations in bright colors.\r\n\r\nFocus developers can easily edit the API Document using the OpenAPI editor interface.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.3.1.\r\n\r\nShow the **API Details** (A) and **Resources and Operations** (B) sections.\r\n\r\n  ![](images/api-doc-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.2.\r\n\r\nClick on **Edit API Document in OpenAPI editor**.\r\n\r\n  ![](images/api-doc-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.3.\r\n\r\nIf necessary, accept the incoming network connections.\r\n\r\n  ![](images/api-doc-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.4.\r\n\r\nShow the *OpenAPI Editor*.\r\n\r\n  ![](images/api-doc-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **2. Add a new operation**\r\n\r\n<details>\r\n<summary>2.1. Adding a new path</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Integration experts decided to create a new API operation to list the products of a specific department.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.1.1.\r\n\r\nOn the **Path** section, on left menu, click on the **Plus** button.\r\n\r\n  ![](images/new-path-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.1.2.\r\n\r\nEnter **/shoppinglist/{department}** as the new *Path* (A). You are welcome to enter a *summary* (B) and *description* (C). Then click **Add** (D).\r\n\r\n  ![](images/new-path-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>2.2. Adding a new operation</summary><br/>\r\n\r\n**Narration**\r\n\r\nThey go ahead and create a new path with the GET operation in the ShoppingListAPI.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.2.1.\r\n\r\nOn the **Operations** section of the new path, click on the **Plus** button.\r\n\r\n  ![](images/new-oper-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.2.2.\r\n\r\nSelect the **get** verb (A) and click **Add** (B).\r\n\r\n  ![](images/new-oper-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>2.3. Defining parameter</summary><br/>\r\n\r\n**Narration**\r\n\r\nThis new path will receive the product department as parameter in the path request.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.1.\r\n\r\nScroll down to see the *Parameter* section (A) and click **Add** button (B).\r\n\r\n  ![](images/def-param-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.2.\r\n\r\nEnter **department** as *Parameter name* (A) and select **path** in *Located In* field (B).\r\n\r\n  ![](images/def-param-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.3.\r\n\r\nScroll down to see the checkbox list and select **Required** field (A). Then click **Add** (B).\r\n\r\n  ![](images/def-param-3.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>2.4. Defining schema</summary><br/>\r\n\r\n**Narration**\r\n\r\nFocus developers define the schema of the parameter as a simple string.\r\n\r\nGreat, Focus’ developers successfully created a new operation in the ShoppingListAPI!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.1.\r\n\r\nScroll down to see the *Schema* section and type **department** as *Title* (A) and select **string** as *Type* (B).\r\n\r\n  ![](images/def-schema-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.2.\r\n\r\nScroll up and click **Save**.\r\n\r\n  ![](images/def-schema-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.3.\r\n\r\n**Close** the OpenAPI editor.\r\n\r\n***\r\n</details>\r\n\r\n\r\n<br/><br/>\r\n\r\n### **3. Create Subflow**\r\n<details>\r\n<summary>3.1. Creating GetDepartment Subflow</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith IBM App Connect it is really simple to implement the logic of your API operation. The Focus team can easily create a subflow to do it!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 3.1.1.\r\n\r\nBack to the ShoppingListAPI description, open the **/shoppinglist/{department}** section.\r\n\r\n  ![](images/create-subflow-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 3.1.2.\r\n\r\nClick **Create subflow**.\r\n\r\n  ![](images/create-subflow-2.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>3.2. Connecting nodes</summary><br/>\r\n\r\n**Narration**\r\n\r\nHere the Focus team has their subflow. A message flow is a sequence of processing steps that run in the integration runtime when an input message is received. You define a message flow by including a number of message flow nodes, each of which represents a set of actions that define a processing step.\r\n\r\nIn the flow editor, they can edit and change their flow. Message flows are created in the Toolkit using a drag and drop editor.\r\n\r\nThe flow is quite simple, consisting of only an Input and Output node. However, the Integration experts would like to explore how to do some message transformations. Let's see how simple is to do it!\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 3.2.1.\r\n\r\nIn the subflow, wire the **Input** node to the **Output** node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Output* node)\r\n\r\n  ![](images/connect-nodes-1.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n\r\n### **4. Using the Mapping Assist feature**\r\n<details>\r\n<summary>4.1. Add Mapping Transformation</summary><br/>\r\n\r\n**Narration**\r\n\r\nFirst, they decided to explore the Mapping transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.1.1.\r\n\r\nOpen the **Transformation** section in the Palette.\r\n\r\n  ![](images/add-mapping-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.1.2.\r\n\r\nDrag and drop a **Mapping** node on to the wire and its terminals will be connected for you (the out terminal of the Input node will be wired to the in terminal of the Mapping node, and the out terminal of the Mapping node will be wired to the in terminal of the Output node).\r\n\r\n  ![](images/add-mapping-2.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>4.2. Editing Mapping</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith a mapping, they can use the Graphical Data Mapping editor to take input (source) objects and transform them before they save the resulting output (target) objects.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.2.1.\r\n\r\nDouble-click the **Mapping** node.\r\n\r\n  ![](images/edit-mapping-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.2.2.\r\n\r\nLeave the default settings and click **Finish**.\r\n\r\n  ![](images/edit-mapping-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.3. Adding new output</summary><br/>\r\n\r\n**Narration**\r\n\r\nInitially, they will change the output object to use the Item JSON type.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.1.\r\n\r\nClick on “**Add an output object**” button.\r\n\r\n  ![](images/new-output-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.2.\r\n\r\nOn the “Select a map output” option, open (double click) the **ShoppingListAPI** (A), open the **JSON Types** (B) and select **Item - Rest API model** (C), then click **OK** (D).\r\n\r\n  ![](images/new-output-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.3.\r\n\r\nSelect the original **Message Assembly** (A), right click and select **delete** (B) (or press delete on your keyboard).\r\n\r\n  ![](images/new-output-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.4. Move Department value</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe input objects are shown on the left side of the canvas, and the output objects are shown on the right side. You can create connections between the input and output elements by clicking one element, and dragging the mouse to the element that you want to connect to.\r\n\r\nThe Focus team can easily link the Department input parameter to the Department parameter of Item JSON Type.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.1.\r\n\r\nExpand the **JSON** message assembly on the right (A), then expand the **Data** section underneath (B). Notice that department is listed as a *parameter* (C).\r\n\r\n  ![](images/move-dept-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.2.\r\n\r\nOn the left Message Assembly, open the **LocalEnvironment > REST > Input > Parameters**.\r\n\r\n  ![](images/move-dept-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.3.\r\n\r\nRight-click the **department** entry (A) and select **Quick Link to Output** (B).\r\n\r\n  ![](images/move-dept-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.4.\r\n\r\nIn the dialog, scroll down and expand **Data : Item [1..1]** (A) and select **department:string [1..1]** (B).\r\n\r\n  ![](images/move-dept-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.5. Setting Cardinality</summary><br/>\r\n\r\n**Narration**\r\n\r\nThey use the Quick Fix capability to solve the cardinality issue of the new mapping.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.5.1.\r\n\r\nHover the mouse over the **Quick Fix** (light bulb) icon of the new *Move* box (A) and click the \"**Set cardinality to first index**” link (B).\r\n\r\n  ![](images/quick-fix-1.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.6. Assigning values</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, for demo purposes, they will use the assign function to define a hard coded value to the name and description fields.  In this demo, they decided to use the description field to just inform the type of transformation node that is processing the transformation, in this case the Mapping node.\r\n\r\nGreat, Focus’ developers successfully created a mapping transformation in the ShoppingListAPI!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.1.\r\n\r\nOn the new Message Assembly JSON, drag and drop the **name** field to the left (A).  IBM App Connect Enterprise places an **Assign** action for this field (B). \r\n\r\n  ![](images/assign-values-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.2.\r\n\r\nSelect the **Assign** action (A). Under the **Properties** for the Assign action, enter “**Caramel Candy Bars**” for the name value (B).\r\n\r\n  ![](images/assign-values-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.3.\r\n\r\nRepeat the same steps for the description field: drag and drop the **description** field to the left (A).  IBM App Connect Enterprise places an **Assign** action for this field (B). \r\n\r\n  ![](images/assign-values-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.4.\r\n\r\nSelect the **Assign** action (A). Under the **Properties** for the Assign action, enter “**Request has been processed by Mapping Node**” for the name value (B).\r\n\r\n*Note: In this demo, we are using the description field to just inform the node that is processing the transformation.*\r\n\r\n  ![](images/assign-values-4.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.5.\r\n\r\nClick **File > Save all**.\r\n\r\n  ![](images/assign-values-5.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<br/><br/>\r\n\r\n### **5. Create local test server**\r\n<details>\r\n<summary>5.1. Creating a local integration server</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, they are ready to test the API. To publish the API, first they need to create a local integration server.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.1.1.\r\n\r\nRight-click **Integration Servers** in the **Integration Explorer** tab (A) and select **Create a local Integration Server** (B).\r\n\r\n  ![](images/local-server-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.1.2.\r\n\r\nKeep the default values and click **Finish**.\r\n\r\n  ![](images/local-server-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.1.3.\r\n\r\nOn the *Success* Dialog click **OK**.\r\n\r\n  ![](images/local-server-3.png)\r\n\r\n<br/>\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>5.2. Adding CORS authorization</summary><br/>\r\n\r\n**Narration**\r\n\r\nNext, they need to configure the server so that the HTTP listener is enabled for CORS. \r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.2.1.\r\n\r\nExpand the **TEST_SERVER** directory under the **Independent Resources** folder (A) and double-click the **server.conf.yaml** file (B) to open it in the IBM App Connect Enterprise text editor to the right.\r\n\r\n  ![](images/cors-auth-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.2.2.\r\n\r\nScroll down to the **HTTPConnector** section and paste the code below:\r\n\r\n```\r\nCORSEnabled: true\r\nCORSAllowOrigins: '*'\r\nCORSAllowMethods: 'GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS'\r\nCORSAllowHeaders: 'Accept,Accept-Language,Content-Language,Content-Type'\r\n```\r\n\r\n<br/>\r\n\r\n  ![](images/cors-auth-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.3.\r\n\r\n**Save** the changes to the **server.conf.yaml** file or click **File** (A) > **Save All** (B).\r\n\r\n  ![](images/cors-auth-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.4.\r\n\r\nBack to the *Integration Explorer* view, right-click the **TEST_SERVER** (A) and select **Restart** (B).\r\n\r\n  ![](images/cors-auth-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.5.\r\n\r\nClick **OK** on the Success dialog again.\r\n\r\n  ![](images/cors-auth-5.png)\r\n\r\n<br/>\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **6. Test the API**\r\n<details>\r\n<summary>6.1. Deploying the API</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, they need to deploy the ShoppingListAPI to the new Local Integration server. They can do it, by dragging and dropping the API to the new server.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.1.1.\r\n\r\nDeploy the REST API which we created earlier named **ShoppingListAPI** (A), by dragging and dropping it from the Application Development view on to the **TEST_SERVER** Integration Server (B).\r\n\r\n  ![](images/deploy-api-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.1.2.\r\n\r\nOn the *Progress Information* dialog, click **Close**.\r\n\r\n  ![](images/deploy-api-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>6.2. Starting Web User Interface</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the API. They start the Web User Interface.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 6.2.1.\r\n\r\nRight-click **TEST_SERVER** (A) and select **Start Web User Interface** (B). \r\n\r\n  ![](images/start-wui-1.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>6.3. Testing the ShoppingList API</summary><br/>\r\n\r\n**Narration**\r\n\r\nSelect the ShoppingListAPI and the new Get Department operation. Note they can use the Try it capability, and enter any product department, for example “Candies”.\r\n\r\nGreat, the subflow was invoked and our mapping transformation created a response with our hard coded values. The Focus team verified it is really simple to implement a mapping transformation using IBM App Connect.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 6.3.1.\r\n\r\nClick the **ShoppingListAPI** tile in the web user interface. \r\n\r\n  ![](images/test-api-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.2.\r\n\r\nSelect the **GET /shoppinglist/{department}** operation on the left. \r\n\r\n  ![](images/test-api-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.3.\r\n\r\nClick the **Try it** tab.\r\n\r\n  ![](images/test-api-3.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.4.\r\n\r\nEnter any **department** name (by now, we are not checking the department) such as **Candies** (A). Click **Send** (B).\r\n\r\n  ![](images/test-api-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.5.\r\n\r\nShow the **Response body**. Show the assigned name and description fields.\r\n\r\n  ![](images/test-api-5.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n\r\n### **7. Add Compute transformation**\r\n<details>\r\n<summary>7.1. Adding Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Focus developers heard about ESQL language. Extended Structured Query Language (ESQL) is a programming language based on Structured Query Language (SQL) that is typically used to work with databases. ESQL is extended to access and manipulate data in messages and databases.\r\n\r\nThey would like to see how to use ESQL to transform and enrich messages using the Compute node.  Because of it, they decided to explore the Compute node transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.1.1.\r\n\r\nBack to the **getDepartment.subflow** (A), open again the Transformation menu and drag and drop a **Compute** node (B).\r\n\r\n  ![](images/add-compute-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.1.2.\r\n\r\nReadjust the connections of the *Input* and *Output* nodes to connect to the *Compute* node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Compute* node, and the *out* terminal of the *Compute* node will be wired to the *in* terminal of the *Output* node).\r\n\r\n  ![](images/add-compute-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.1.3.\r\n\r\nClick on the **Compute** node (A). On the Compute node's properties change the *Compute mode* to be “**LocalEnvironment and Message**” (B).\r\n\r\n  ![](images/add-compute-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.1.4.\r\n\r\n**Save** the subflow (you can safely ignore the red crosses on the Compute node - we will fix these up in the next step!).\r\n\r\n  ![](images/add-compute-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.2. Create Broker Schema</summary><br/>\r\n\r\n**Narration**\r\n\r\nTo simplify the demo, they decided to reuse a pre-created ESQL file.\r\n\r\nFirst, they need to create a Broker Schema to include the ESQL file. A broker schema is a symbol space that defines the scope of uniqueness of the names of resources defined within it.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.1.\r\n\r\nRight click the **ShoppingListAPI**  and choose **New > Broker Schema**.\r\n\r\n  ![](images/broker-schema-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.2.\r\n\r\nType **utils** as the Schema name (A) and click **Finish** (B).\r\n\r\n  ![](images/broker-schema-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.3.\r\n\r\nOn the *New Broker Schema* dialog, click **OK**.\r\n\r\n  ![](images/broker-schema-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.3. Copy ESQL file</summary><br/>\r\n\r\n**Narration**\r\n\r\nNext, Focus developers will copy the pre-created ESQL file to the broker schema folder.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.1.\r\n\r\nSwitch to the Resource perspective using the menu **Window > Perspective > Open Perspective > Other…**\r\n\r\n  ![](images/copy-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.2.\r\n\r\nChoose **Resource** (A) and click **Open** (B).\r\n\r\n  ![](images/copy-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.3.\r\n\r\nUsing the Project Explorer view, open the *HelperFiles* project and the **utils** folder, right click on the **Compute.esql** file (A) and select **Copy** (B).\r\n\r\n  ![](images/copy-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.4.\r\n\r\nOn the **ShoppingListAPI** project, right click on the **utils** folder, and select **Paste**.\r\n\r\n  ![](images/copy-esql-4.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.5.\r\n\r\nSwitch back to the *Integration Development* perspective using the **Window > Perspective > Open Perspective > Integration Development** menu.\r\n\r\n  ![](images/copy-esql-5.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.4. Update the ESQL module</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, they just need to update the Compute node to use the new ESQL file. They will use a specific module of the ESQL file: the getDepartment.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.1.\r\n\r\nReturn to the *getDepartment* subflow and click on **Compute** node again.\r\n\r\n  ![](images/update-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.2.\r\n\r\nOn the Compute node's properties, you need to update the *ESQL module* property. Click **Browse** button.\r\n\r\n  ![](images/update-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.3.\r\n\r\nSelect **{utils}:getDepartment_Compute** (A) and click **OK** (B).\r\n\r\n  ![](images/update-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.4.\r\n\r\n**Save** the subflow.\r\n\r\n  ![](images/update-esql-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.5. Review the ESQL</summary><br/>\r\n\r\n**Narration**\r\n\r\nLet's review the ESQL file. Focus developers can create and modify their ESQL code in the ESQL editor.\r\n\r\nThe ESQL code for each of your nodes is contained within a module in an ESQL file. Here they have a specific module for getDepartment operation.  The module is simple; just select the Item where the Department value equals the Department parameter.\r\n\r\nAll three items are hardcoded and created in the Initialise procedure. In a real scenario, this data should be retrieved from the Products database or Product system.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.1.\r\n\r\n**Double click** on the **Compute** node, to see the ESQL file.\r\n\r\n  ![](images/review-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.2.\r\n\r\nShow the **getDepartment_Compute Module**.\r\n\r\n  ![](images/review-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.3.\r\n\r\nScroll down and show the **Initialise Procedure**.\r\n\r\n  ![](images/review-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.4.\r\n\r\n**Close** the ESQL file.\r\n\r\n  ![](images/review-esql-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.6. Test compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the new API. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using the three available departments: Candies, Snacks and Bakery.\r\n\r\nGreat, the subflow was invoked and our compute transformation created a response with our hard coded values. The Focus team verified how simple it is to use ESQL query language to implement message transformations.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-compute-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-compute-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.3.\r\n\r\nOn your browser, refresh the **Web User Interface** page.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), and **Try it** tab (C).\r\n\r\n  ![](images/test-compute-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.5.\r\n\r\nEnter a **department** name (it could be Candies, Snacks or Bakery)  (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments or try a different one to see the 404 Not Found message*.\r\n\r\n  ![](images/test-compute-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.6.\r\n\r\nShow the **Response** body.\r\n\r\n  ![](images/test-compute-6.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **8. Add Java transformation**\r\n<details>\r\n<summary>8.1. Adding Java Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nGreat, now the Focus Developers would like to see how to use Java code to tailor the behavior of their integration messages.\r\n\r\nThey want to learn how to use the JavaCompute node to examine the content of an input message, transform a message, and build new messages.\r\n\r\nBecause of this, they decided to explore the JavaCompute node.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.1.1.\r\n\r\nBack to the *getDepartment.subflow*, open again the *Transformation* menu and drag and drop a **JavaCompute** node.\r\n\r\n  ![](images/add-javacompute-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.1.2.\r\n\r\nReadjust the connections of the Input and output node to connect to the Java Compute node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Java Compute* node, and the *out* terminal of the *Java Compute* node will be wired to the *in* terminal of the *Output* node).\r\n\r\n  ![](images/add-javacompute-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.2. Create Java Compute node class</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith the App Connect toolkit, they can use the same tool that they use to create Integration flow to create Java code. Alternatively, if they want to share Java classes across multiple solutions, they can store Java code in a shared library and refer to that library from one or more applications that contain message flows with JavaCompute nodes\r\n\r\nHowever, the developers decided to try the Java Compute node class wizard to create template code to accelerate the development process. They selected the Modifying message class template, and in few seconds, they have a skeleton java code to manipulate and transform the integration message.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.1.\r\n\r\n*Double click* the **Java Compute** node.\r\n\r\n  ![](images/create-javaclass-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.2.\r\n\r\nOn the *New JavaCompute node class* dialog, accept the default values and click **Next**.\r\n\r\n  ![](images/create-javaclass-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.3.\r\n\r\nSelect **Modifying message class** template (A) and click **Next** (B).\r\n\r\n  ![](images/create-javaclass-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.4.\r\n\r\nOn the Java Settings view, accept the default values and click **Next**.\r\n\r\n  ![](images/create-javaclass-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.5.\r\n\r\nAccept the default Project name and click **Finish**.\r\n\r\n  ![](images/create-javaclass-5.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.3. Adding code</summary><br/>\r\n\r\n**Narration**\r\n\r\nFor this demo, they will only add a simple message code to create elements in the JSON message, for example add a new Apple Pie product item.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.1.\r\n\r\nOn the *GetDepartment_JavaCompute* class, **copy and paste the code below**, below the *Add user code below* comment.\r\n```\r\nMbElement outRoot = outMessage.getRootElement();\r\nMbElement outJsonRoot = outRoot.createElementAsLastChild(MbJSON.PARSER_NAME);\r\nMbElement outJsonData = outJsonRoot.createElementAsLastChild(MbElement.TYPE_NAME, MbJSON.DATA_ELEMENT_NAME, null);\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"name\", \"Apple Pie\");\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"department\", \"Bakery\");\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"description\", \"Request has been processed by Java Compute Node.\");\r\n```\r\n\r\n<br/>\r\n\r\n  ![](images/add-code-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.2.\r\n\r\nTo solve the imports issue, click on **Source > Organize Imports** menu.\r\n\r\n  ![](images/add-code-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.3.\r\n\r\nClick **File > Save All**.\r\n\r\n  ![](images/add-code-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.4.\r\n\r\n**Close** the Java class.\r\n\r\n  ![](images/add-code-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.4. Test Java Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the new API using the JavaCompute node. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using the Bakery department only.\r\n\r\nGreat, the subflow was invoked and our java compute transformation created a response with our hard coded Apple Pie product. The Focus team verified how simple it is to use Java code to implement message transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-java-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-java-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.3.\r\n\r\nOn your browser, **refresh** the *Web User Interface* page.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), **Try it** tab (C).\r\n\r\n  ![](images/test-java-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.5.\r\n\r\nEnter **Bakery** as **department** name (A). Click **Send** (B).\r\n\r\n  ![](images/test-java-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.6\r\n\r\nShow the **Response** body.\r\n\r\n  ![](images/test-java-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **9. Add Route**\r\n<details>\r\n<summary>9.1. Adding Route node</summary><br/>\r\n\r\n**Narration**\r\n\r\nFinally, they want to see how they can route messages through different paths in a message flow, based on the content of the message using a Route node.\r\n\r\nFocus Integration experts decided to add a route node to route messages through all different transformation nodes based on the department parameter.  The idea is to redirect to Mapping node only messages to Candies department, redirect to Compute node only messages to Snacks department and redirect to Java node only messages to Bakery department.\r\n\r\nLet's see how to do it!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.1.1.\r\n\r\nBack to the getDepartment subflow, open the **Routing** menu and drag and drop a **Route** node.\r\n\r\n  ![](images/add-route-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.1.2.\r\n\r\nDelete all existing wiring and connect the **Input** node to the new **Route** node.\r\n\r\n  ![](images/add-route-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.2. Renaming Match output terminal</summary><br/>\r\n\r\n**Narration**\r\n\r\nInitially, they need to rename the existing Match output terminal to mapping. And connect this terminal with the Mapping node.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.2.1.\r\n\r\nRight click on **Route** node (A) and select **Rename Output Terminal** (B).\r\n\r\n  ![](images/rename-terminal-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.2.2\r\n\r\n*On Select output terminal to rename* field, select **Match** (A). In the *Enter new name for the selected output terminal*, enter **mapping** (B). Then click **OK** (C).\r\n\r\n  ![](images/rename-terminal-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.2.3.\r\n\r\nWire the **mapping** output terminal from **Route** node to the **in** terminal of the **Mapping node**.\r\n\r\n  ![](images/rename-terminal-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.3. Creating new output terminal</summary><br/>\r\n\r\n**Narration**\r\n\r\nSecond, they need to create two more output terminals to the compute and java transformation nodes. Connect these terminals to the Compute and JavaCompute nodes.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.3.1.\r\n\r\nRight click on **Route** node (A) and select **Add Output Terminal** (B).\r\n\r\n  ![](images/new-terminal-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.2.\r\n\r\nEnter **compute** as the name of the new output terminal (A) and click **OK** (B).\r\n\r\n  ![](images/new-terminal-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.3.\r\n\r\nRepeat the same steps to create the java terminal: Right click on **Route** node (A) and select **Add Output Terminal** (B).\r\n\r\n  ![](images/new-terminal-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.4.\r\n\r\nEnter **java** as the name of the new output terminal (A) and click **OK** (B).\r\n\r\n  ![](images/new-terminal-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.5.\r\n\r\nWire the **compute** output terminal from **Route** node to the **in** terminal of the **Compute** node.\r\n\r\n*Note: if you click the output terminals from Route, you will see a dialog to select the terminal that you want to wire.*\r\n\r\n  ![](images/new-terminal-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.6.\r\n\r\nRepeat the same steps to wire the **java** output terminal from **Route** node to the **in** terminal of the **Java Compute** node.\r\n\r\n*Note: if you click the output terminals from Route, you will see a dialog to select the terminal that you want to wire.*\r\n\r\n  ![](images/new-terminal-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.4. Adding filter patterns</summary><br/>\r\n\r\n**Narration**\r\n\r\nGreat! Now, they are ready to define the filter table. The Route node uses XPath expressions to control processing.\r\n\r\nFocus developers define the three XPath expressions, one for each transformation node.  The filter table map the XPath with the specific output terminal. The XPath is checking the department parameter value for each department.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.4.1.\r\n\r\nClick on the **Route** node.\r\n\r\n  ![](images/filter-patterns-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.2.\r\n\r\nOn the Filter table, click **Add** button.\r\n\r\n  ![](images/filter-patterns-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.3.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Candies\"** in the *Filter pattern* field (A) and select **mapping** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.4.\r\n\r\nClick **Add** button again.\r\n\r\n  ![](images/filter-patterns-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.5.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Snacks”** in the *Filter pattern* field (A) and select **compute** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.6.\r\n\r\nClick **Add** button again.\r\n\r\n  ![](images/filter-patterns-6.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.7.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Bakery”** in the *Filter pattern* field (A) and select **java** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-7.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.5. Connecting nodes</summary><br/>\r\n\r\n**Narration**\r\n\r\nFinally, the Focus team connects all the nodes to finalize the flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.5.1.\r\n\r\nWire the *out* terminal of **Mapping**, **Compute** and **Java Compute** nodes to the *in* terminal of the **Output** node.\r\n\r\n  ![](images/route-connect-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.5.2.\r\n\r\nWire the *default* and *failure* terminal of **Route** node to the *in* terminal of the **Output** node.\r\n\r\n  ![](images/route-connect-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.5.3.\r\n\r\nClick **File > Save All**.\r\n\r\n  ![](images/route-connect-3.png)\r\n\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.6. Test Route node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, the Focus Integration experts are ready to test the new API using the route node. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using all three departments: Candies, Bakery and Snacks.\r\n\r\nGreat, the subflow was invoked and  the message is routed through all different transformation nodes based on the department parameter.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-route-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-route-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.3.\r\n\r\nOn your browser, **refresh** the **Web User Interface** page.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), **Try it** tab (C).\r\n\r\n  ![](images/test-java-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.5.\r\n\r\nEnter **Candies** (or Bakery, or Snacks) as **department** name (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments.*\r\n\r\n  ![](images/test-route-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.6.\r\n\r\nShow the **Response** body and show that each department is processed by different Transformation node (show the description field).\r\n\r\n  ![](images/test-route-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **10. Test on App Connect Enterprise**\r\n<details>\r\n<summary>10.1. Exporting BAR File</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, the Focus team is ready to deploy their Integration flow in an App Connect Server. They just need to generate a BAR (broker archive) file. The App Connect Enterprise server uses BAR files to save compiled message flows, libraries, and other elements critical to the Integration flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.1.\r\n\r\nRight click the **ShoppingListAPI** (A) and choose **New > BAR file** (B).\r\n\r\n  ![](images/bar-file-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.2.\r\n\r\nOn the *New Bar file* dialog, type **shoppinglist** as the bar file name (A) and click **Finish** (B).\r\n\r\n  ![](images/bar-file-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.3.\r\n\r\nOn the *Prepare screen*, mark the **REST APIs** checkbox (A). Check **Compile and in-line resources** (B). Click **Build and Save** (C).\r\n\r\n  ![](images/bar-file-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.4.\r\n\r\nNow, a popup window displays *Operation completed successfully*. Click **OK**.\r\n\r\n  ![](images/bar-file-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.2. Accessing App Connect Enterprise environment</summary><br/>\r\n\r\n**Narration**\r\n\r\nIBM App Connect is an industry-leading integration solution that connects any of your applications and data, no matter where they reside. With hundreds of prebuilt connectors and customizable templates, App Connect helps users of all skill levels rapidly connect Software as a Service (SaaS) applications and build integration flows.\r\n\r\nFor this demo, Focus Corp is using a trial account of IBM App Connect Enterprise as a Service on AWS.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.2.1.\r\n\r\nIn your email inbox (that you used to create the App Connect trial account), search for **IBM SaaS** (A), open the ”**Your IBM App Connect trial is ready**” email (B).\r\n\r\n  ![](images/ace-access-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.2.\r\n\r\nNow, click the **Access trial** button.\r\n\r\n  ![](images/ace-access-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.3.\r\n\r\n**Log in** with your App Connect *username* and *password*.\r\n\r\n  ![](images/ace-access-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.4\r\n\r\nUse the Instance switcher to change to the **Dashboard** instance.\r\n\r\n  ![](images/ace-access-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.3. Creating Integration server</summary><br/>\r\n\r\n**Narration**\r\n\r\nFocus integration experts begin in the IBM App Connect Dashboard. Here they can administer integration servers and integration runtimes, which are deployed from the BAR files mentioned earlier. They want to deploy the Integration flow defined in the previous steps.\r\n\r\nBecause they need to deploy a simple integration, let’s select with the Quick start integration type.\r\n\r\nNow they need to provide the BAR file. The BAR file contains all the resources that are needed to deploy an integration. The BAR file parameters will expose both the integration and its operations.\r\n\r\nThey can use the Configuration component to apply any customizations to the integration server when they deploy it. For their scenario, they don’t need to use the configuration package.\r\n\r\nNow, they need to define a name for their Integration server, for example shoppinglist.\r\n\r\nThat is it! After few minutes their server should be ready with their integration flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.1.\r\n\r\nClick **Deploy integrations**.\r\n\r\n  ![](images/inter-server-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.2.\r\n\r\nSelect **Quick start integration** option (A) and click **Next** (B).\r\n\r\n  ![](images/inter-server-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.3.\r\n\r\nClick to upload your BAR File. And select the **shoppinglist.bar** (A) file (it is in your workspace folder in a Bar Files directory). And click **Next** (B).\r\n\r\n  ![](images/inter-server-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.4.\r\n\r\nYou don’t need any Integration configuration, click **Next**.\r\n\r\n  ![](images/inter-server-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.5.\r\n\r\nEnter the Integration Server name as **shoppinglist** (A). Disable the option to **Force Flow Basic Auth** (B). Then click **Create** (C).\r\n\r\n  ![](images/inter-server-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.6.\r\n\r\nThe deployment process takes up to 5 minutes, **refresh** the browser to see the BAR file deployed and started.\r\n\r\n  ![](images/inter-server-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.4. Testing the API</summary><br/>\r\n\r\n**Narration**\r\n\r\nTo finalize, the Focus Integration experts would like to test the new API in the App Connect Enterprise environment. They just need to open the Integration server and the API.\r\n\r\nNow, using the Try it capability, they will test using all three departments: Candies, Bakery and Snacks.\r\n\r\nGreat, the subflow was invoked and the message is routed through all different transformation nodes based on the department parameter.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.1.\r\n\r\nClick the **shoppinglist** server icon.\r\n\r\n  ![](images/final-test-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.2.\r\n\r\nClick the **ShoppingListAPI** icon.\r\n\r\n  ![](images/final-test-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.3.\r\n\r\nIgnore the Open API Validation errors. Click on **GET /shoppinglist/{department}**,\r\n\r\n  ![](images/final-test-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.4.\r\n\r\nOpen the **Try it** tab.\r\n\r\n  ![](images/final-test-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.5.\r\n\r\nEnter **Candies** (or **Bakery**, or **Snacks**) as *department* name (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments.*\r\n\r\n  ![](images/final-test-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.6.\r\n\r\nShow the **Response** body and show that each department is processed by different Transformation node (show the description field).\r\n\r\n  ![](images/final-test-6.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n### **Summary**\r\n\r\n<br/>\r\nLet’s summarize what Focus developers have done today. In this demo they: <br/>\r\n<ul>\r\n<li>Created Rest API using the App Connect Toolkit</li>\r\n<li>Created new API operation using the OpenAPI editor</li>\r\n<li>Implemented mapping transformation using the Mapping node</li>\r\n<li>Implemented compute transformation using ESQL query language and Compute node</li>\r\n<li>Implemented java transformation using Java code and JavaCompute node</li>\r\n<li>Implemented messaging routing using Route node</li>\r\n<li>Deployed and tested the Integration flow on IBM App Connect Enterprise as a Service on AWS</li>\r\n</ul><br/>\r\nIn this demo, Focus Integration experts learned how to build complex, multi-style integrations with support for multiple programming languages and fully integrated with source and pipeline management tools using the IBM App Connect toolkit.\r\n<br/><br/>\r\nThank you for attending today’s presentation.\r\n<br/>\r\n","type":"Mdx","contentDigest":"8749f3686dc175914bc9229ee336ce5a","owner":"gatsby-plugin-mdx","counter":1387},"frontmatter":{"title":"ACE Toolkit Demo","description":"ACE Toolkit Demo for TechSales","tabs":["Demo preparation","Demo script"]},"exports":{},"rawBody":"---\r\ntitle: ACE Toolkit Demo\r\ndescription: ACE Toolkit Demo for TechSales\r\ntabs: [ 'Demo preparation', 'Demo script']\r\n---\r\n\r\n\r\n<FeatureCard\r\n  title=\"Create integrations with App Connect for Developers Toolkit - Demo Script\"\r\n  color=\"dark\"\r\n  >\r\n\r\n![banner](./images/banner-ace-toolkit.jpg)\r\n\r\n</FeatureCard>\r\n\r\n\r\n<span id=\"place1\"></span>\r\n\r\n### **Introduction**\r\n<br/>\r\nToday's organizations use a wide variety of diverse Software as a Service (SaaS) applications, often without centralized coordination between them. However, integrating applications  is essential to help organizations increase efficiency and optimize business workflows. For instance, in a typical sales process without application integration, sales reps may use Salesforce for customer relationships and Excel for quotes. After finalizing a sale, they must manually transfer data such as customer details, product information, and pricing data from Salesforce to Excel. This can be time-consuming and prone to errors, leading to delays in processing sales orders and potential inaccuracies in pricing.\r\n<br/><br/>\r\nBy connecting your apps using IBM App Connect, the process becomes more streamlined, accurate and efficient because reps can automate data input to create quotes directly from their CPQ application with centralized tracking.\r\n<br/><br/>\r\nIBM App Connect can help you securely connect all your endpoints, from databases to packaged apps. It provides  an out-of-the-box set of capabilities that will accelerate  SaaS integration and automation across your business. Additionally, the development kit allows citizen integrators to understand and build powerful integrations with little to no training.\r\n<br/><br/>\r\nFocus Corporation, a hypothetical retail company engaged with IBM, is highly motivated to derive more revenue from first-time customers to their online storefronts. Focus has acquired another business and needs to integrate the different IT applications.\r\n<br/><br/>\r\nThe Focus Integration expert would like to build complex, multi-style integrations with support for multiple programming languages and fully integrated with source and pipeline management tools like GIT, Maven, Jenkins, etc. \r\n<br/><br/>\r\nThe Focus team requested a demo to learn how IBM App Connect for Developers Toolkit can help them to implement complex and advanced integration scenarios.\r\n<br/><br/>\r\n\r\n\r\n### **1. Create your Integration flow**\r\n\r\n<details>\r\n<summary>1.1. Starting App Connect Toolkit</summary><br/>\r\n\r\n**Narration**\r\n\r\nIBM App Connect is an industry-leading integration solution that connects any of your applications and data, no matter where they reside. With hundreds of prebuilt connectors and customizable templates, App Connect helps users of all skill levels rapidly connect Software as a Service (SaaS) applications and build integration flows.\r\n\r\nThe Focus team is looking for an advanced, fully customizable code platform. They would like to harness a lightweight, fast-performing engine that easily scales to support their growing needs. They need to enable support for multiple types of data integration, including event, application programming interfaces (APIs), services, sync/async, transactional batch processing and more. Focus Integration experts need to map data fields and transform data formats exchanged between applications, such as XML, JSON, CSV, EDIFACT, SWIFT and other industry protocols.\r\n\r\nBecause of that, they decided to explore IBM App Connect Enterprise for Developers (Toolkit). The Toolkit is an integrated development environment and graphical user interface based on the Eclipse platform. Focus Integration experts can use the IBM App Connect Enterprise Toolkit to build powerful integration applications, services, and APIs. And they can then deploy their integration solutions to the software run time, IBM App Connect Enterprise as a Service, containers, or a combination of those environments.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.1.1.\r\n\r\nOpen your **App Connect Enterprise Toolkit** by clicking the icon on the Launchpad (MAC OS) or Desktop (Windows) or executing **ace toolkit** in terminal window.\r\n\r\n  ![](images/start-toolkit-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.1.2.\r\n\r\nIn the Workspace Launcher window, accept the default one. Click **Launch**.\r\n\r\n  ![](images/start-toolkit-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.1.3.\r\n\r\n**Close** the *welcome page*.\r\n\r\n  ![](images/start-toolkit-3.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>1.2. Creating a REST API</summary><br/>\r\n\r\n**Narration**\r\n\r\nFrom the Integration Development perspective, Focus Integration experts can create all manner of integration flows, as well as manage connectivity between services and endpoints.\r\n\r\nThe Focus team would like to explore how easy is to create an API flow that implements different types of message transformation.\r\n\r\nApp Connect provides a specific type of project to support REST API implementations, which can either be based upon a Swagger (v2) specification document or an OpenAPI (v3) specification document. REST APIs can be authored and deployed from the IBM App Connect Enterprise Toolkit.\r\n\r\nLet's see how easy is to create a REST API using the Toolkit. The Focus team will create a REST API from an existing OpenAPI v3 document.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.2.1.\r\n\r\nFrom the Application Development view click the **New...** hyperlink at the top right (A) and from the menu which appears, click on **REST API** (B).\r\n\r\n  ![](images/create-rest-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.2.\r\n\r\nType the Name **ShoppingListAPI** (A) and switch the radio button to the option labelled “**Import resources and operations defined in a REST API document**\" (B) then click **Next** (C).\r\n\r\n  ![](images/create-rest-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.3.\r\n\r\nYou will be asked to import an OpenAPI 3 document either from the file system or your workspace. Using the radio button to “**Select from your workspace**” (A), select **ShoppingListAPI.json** from the json folder in the **HelperFiles** project (B) (note: if you don't see the HelperFiles project, maybe you forgot to import this project in the Demo Preparation part). Click **Next** (C).\r\n\r\n  ![](images/create-rest-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.2.4.\r\n\r\nClick **Finish**.\r\n\r\n  ![](images/create-rest-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>1.3. Exploring the REST API details</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Focus team created the REST API and they can see a summary page displaying details about the API such as its title and base URL. The next section down entitled Resources and Operations lists the operations in bright colors.\r\n\r\nFocus developers can easily edit the API Document using the OpenAPI editor interface.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 1.3.1.\r\n\r\nShow the **API Details** (A) and **Resources and Operations** (B) sections.\r\n\r\n  ![](images/api-doc-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.2.\r\n\r\nClick on **Edit API Document in OpenAPI editor**.\r\n\r\n  ![](images/api-doc-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.3.\r\n\r\nIf necessary, accept the incoming network connections.\r\n\r\n  ![](images/api-doc-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 1.3.4.\r\n\r\nShow the *OpenAPI Editor*.\r\n\r\n  ![](images/api-doc-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **2. Add a new operation**\r\n\r\n<details>\r\n<summary>2.1. Adding a new path</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Integration experts decided to create a new API operation to list the products of a specific department.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.1.1.\r\n\r\nOn the **Path** section, on left menu, click on the **Plus** button.\r\n\r\n  ![](images/new-path-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.1.2.\r\n\r\nEnter **/shoppinglist/{department}** as the new *Path* (A). You are welcome to enter a *summary* (B) and *description* (C). Then click **Add** (D).\r\n\r\n  ![](images/new-path-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>2.2. Adding a new operation</summary><br/>\r\n\r\n**Narration**\r\n\r\nThey go ahead and create a new path with the GET operation in the ShoppingListAPI.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.2.1.\r\n\r\nOn the **Operations** section of the new path, click on the **Plus** button.\r\n\r\n  ![](images/new-oper-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.2.2.\r\n\r\nSelect the **get** verb (A) and click **Add** (B).\r\n\r\n  ![](images/new-oper-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>2.3. Defining parameter</summary><br/>\r\n\r\n**Narration**\r\n\r\nThis new path will receive the product department as parameter in the path request.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.1.\r\n\r\nScroll down to see the *Parameter* section (A) and click **Add** button (B).\r\n\r\n  ![](images/def-param-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.2.\r\n\r\nEnter **department** as *Parameter name* (A) and select **path** in *Located In* field (B).\r\n\r\n  ![](images/def-param-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.3.3.\r\n\r\nScroll down to see the checkbox list and select **Required** field (A). Then click **Add** (B).\r\n\r\n  ![](images/def-param-3.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>2.4. Defining schema</summary><br/>\r\n\r\n**Narration**\r\n\r\nFocus developers define the schema of the parameter as a simple string.\r\n\r\nGreat, Focus’ developers successfully created a new operation in the ShoppingListAPI!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.1.\r\n\r\nScroll down to see the *Schema* section and type **department** as *Title* (A) and select **string** as *Type* (B).\r\n\r\n  ![](images/def-schema-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.2.\r\n\r\nScroll up and click **Save**.\r\n\r\n  ![](images/def-schema-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 2.4.3.\r\n\r\n**Close** the OpenAPI editor.\r\n\r\n***\r\n</details>\r\n\r\n\r\n<br/><br/>\r\n\r\n### **3. Create Subflow**\r\n<details>\r\n<summary>3.1. Creating GetDepartment Subflow</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith IBM App Connect it is really simple to implement the logic of your API operation. The Focus team can easily create a subflow to do it!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 3.1.1.\r\n\r\nBack to the ShoppingListAPI description, open the **/shoppinglist/{department}** section.\r\n\r\n  ![](images/create-subflow-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 3.1.2.\r\n\r\nClick **Create subflow**.\r\n\r\n  ![](images/create-subflow-2.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>3.2. Connecting nodes</summary><br/>\r\n\r\n**Narration**\r\n\r\nHere the Focus team has their subflow. A message flow is a sequence of processing steps that run in the integration runtime when an input message is received. You define a message flow by including a number of message flow nodes, each of which represents a set of actions that define a processing step.\r\n\r\nIn the flow editor, they can edit and change their flow. Message flows are created in the Toolkit using a drag and drop editor.\r\n\r\nThe flow is quite simple, consisting of only an Input and Output node. However, the Integration experts would like to explore how to do some message transformations. Let's see how simple is to do it!\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 3.2.1.\r\n\r\nIn the subflow, wire the **Input** node to the **Output** node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Output* node)\r\n\r\n  ![](images/connect-nodes-1.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n\r\n### **4. Using the Mapping Assist feature**\r\n<details>\r\n<summary>4.1. Add Mapping Transformation</summary><br/>\r\n\r\n**Narration**\r\n\r\nFirst, they decided to explore the Mapping transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.1.1.\r\n\r\nOpen the **Transformation** section in the Palette.\r\n\r\n  ![](images/add-mapping-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.1.2.\r\n\r\nDrag and drop a **Mapping** node on to the wire and its terminals will be connected for you (the out terminal of the Input node will be wired to the in terminal of the Mapping node, and the out terminal of the Mapping node will be wired to the in terminal of the Output node).\r\n\r\n  ![](images/add-mapping-2.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>4.2. Editing Mapping</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith a mapping, they can use the Graphical Data Mapping editor to take input (source) objects and transform them before they save the resulting output (target) objects.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.2.1.\r\n\r\nDouble-click the **Mapping** node.\r\n\r\n  ![](images/edit-mapping-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.2.2.\r\n\r\nLeave the default settings and click **Finish**.\r\n\r\n  ![](images/edit-mapping-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.3. Adding new output</summary><br/>\r\n\r\n**Narration**\r\n\r\nInitially, they will change the output object to use the Item JSON type.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.1.\r\n\r\nClick on “**Add an output object**” button.\r\n\r\n  ![](images/new-output-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.2.\r\n\r\nOn the “Select a map output” option, open (double click) the **ShoppingListAPI** (A), open the **JSON Types** (B) and select **Item - Rest API model** (C), then click **OK** (D).\r\n\r\n  ![](images/new-output-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.3.3.\r\n\r\nSelect the original **Message Assembly** (A), right click and select **delete** (B) (or press delete on your keyboard).\r\n\r\n  ![](images/new-output-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.4. Move Department value</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe input objects are shown on the left side of the canvas, and the output objects are shown on the right side. You can create connections between the input and output elements by clicking one element, and dragging the mouse to the element that you want to connect to.\r\n\r\nThe Focus team can easily link the Department input parameter to the Department parameter of Item JSON Type.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.1.\r\n\r\nExpand the **JSON** message assembly on the right (A), then expand the **Data** section underneath (B). Notice that department is listed as a *parameter* (C).\r\n\r\n  ![](images/move-dept-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.2.\r\n\r\nOn the left Message Assembly, open the **LocalEnvironment > REST > Input > Parameters**.\r\n\r\n  ![](images/move-dept-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.3.\r\n\r\nRight-click the **department** entry (A) and select **Quick Link to Output** (B).\r\n\r\n  ![](images/move-dept-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.4.4.\r\n\r\nIn the dialog, scroll down and expand **Data : Item [1..1]** (A) and select **department:string [1..1]** (B).\r\n\r\n  ![](images/move-dept-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.5. Setting Cardinality</summary><br/>\r\n\r\n**Narration**\r\n\r\nThey use the Quick Fix capability to solve the cardinality issue of the new mapping.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.5.1.\r\n\r\nHover the mouse over the **Quick Fix** (light bulb) icon of the new *Move* box (A) and click the \"**Set cardinality to first index**” link (B).\r\n\r\n  ![](images/quick-fix-1.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>4.6. Assigning values</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, for demo purposes, they will use the assign function to define a hard coded value to the name and description fields.  In this demo, they decided to use the description field to just inform the type of transformation node that is processing the transformation, in this case the Mapping node.\r\n\r\nGreat, Focus’ developers successfully created a mapping transformation in the ShoppingListAPI!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.1.\r\n\r\nOn the new Message Assembly JSON, drag and drop the **name** field to the left (A).  IBM App Connect Enterprise places an **Assign** action for this field (B). \r\n\r\n  ![](images/assign-values-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.2.\r\n\r\nSelect the **Assign** action (A). Under the **Properties** for the Assign action, enter “**Caramel Candy Bars**” for the name value (B).\r\n\r\n  ![](images/assign-values-2.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.3.\r\n\r\nRepeat the same steps for the description field: drag and drop the **description** field to the left (A).  IBM App Connect Enterprise places an **Assign** action for this field (B). \r\n\r\n  ![](images/assign-values-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.4.\r\n\r\nSelect the **Assign** action (A). Under the **Properties** for the Assign action, enter “**Request has been processed by Mapping Node**” for the name value (B).\r\n\r\n*Note: In this demo, we are using the description field to just inform the node that is processing the transformation.*\r\n\r\n  ![](images/assign-values-4.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 4.6.5.\r\n\r\nClick **File > Save all**.\r\n\r\n  ![](images/assign-values-5.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<br/><br/>\r\n\r\n### **5. Create local test server**\r\n<details>\r\n<summary>5.1. Creating a local integration server</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, they are ready to test the API. To publish the API, first they need to create a local integration server.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.1.1.\r\n\r\nRight-click **Integration Servers** in the **Integration Explorer** tab (A) and select **Create a local Integration Server** (B).\r\n\r\n  ![](images/local-server-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.1.2.\r\n\r\nKeep the default values and click **Finish**.\r\n\r\n  ![](images/local-server-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.1.3.\r\n\r\nOn the *Success* Dialog click **OK**.\r\n\r\n  ![](images/local-server-3.png)\r\n\r\n<br/>\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>5.2. Adding CORS authorization</summary><br/>\r\n\r\n**Narration**\r\n\r\nNext, they need to configure the server so that the HTTP listener is enabled for CORS. \r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.2.1.\r\n\r\nExpand the **TEST_SERVER** directory under the **Independent Resources** folder (A) and double-click the **server.conf.yaml** file (B) to open it in the IBM App Connect Enterprise text editor to the right.\r\n\r\n  ![](images/cors-auth-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 5.2.2.\r\n\r\nScroll down to the **HTTPConnector** section and paste the code below:\r\n\r\n```\r\nCORSEnabled: true\r\nCORSAllowOrigins: '*'\r\nCORSAllowMethods: 'GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS'\r\nCORSAllowHeaders: 'Accept,Accept-Language,Content-Language,Content-Type'\r\n```\r\n\r\n<br/>\r\n\r\n  ![](images/cors-auth-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.3.\r\n\r\n**Save** the changes to the **server.conf.yaml** file or click **File** (A) > **Save All** (B).\r\n\r\n  ![](images/cors-auth-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.4.\r\n\r\nBack to the *Integration Explorer* view, right-click the **TEST_SERVER** (A) and select **Restart** (B).\r\n\r\n  ![](images/cors-auth-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n\r\n**Action** &nbsp; 5.2.5.\r\n\r\nClick **OK** on the Success dialog again.\r\n\r\n  ![](images/cors-auth-5.png)\r\n\r\n<br/>\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **6. Test the API**\r\n<details>\r\n<summary>6.1. Deploying the API</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, they need to deploy the ShoppingListAPI to the new Local Integration server. They can do it, by dragging and dropping the API to the new server.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.1.1.\r\n\r\nDeploy the REST API which we created earlier named **ShoppingListAPI** (A), by dragging and dropping it from the Application Development view on to the **TEST_SERVER** Integration Server (B).\r\n\r\n  ![](images/deploy-api-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.1.2.\r\n\r\nOn the *Progress Information* dialog, click **Close**.\r\n\r\n  ![](images/deploy-api-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>6.2. Starting Web User Interface</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the API. They start the Web User Interface.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 6.2.1.\r\n\r\nRight-click **TEST_SERVER** (A) and select **Start Web User Interface** (B). \r\n\r\n  ![](images/start-wui-1.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>6.3. Testing the ShoppingList API</summary><br/>\r\n\r\n**Narration**\r\n\r\nSelect the ShoppingListAPI and the new Get Department operation. Note they can use the Try it capability, and enter any product department, for example “Candies”.\r\n\r\nGreat, the subflow was invoked and our mapping transformation created a response with our hard coded values. The Focus team verified it is really simple to implement a mapping transformation using IBM App Connect.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 6.3.1.\r\n\r\nClick the **ShoppingListAPI** tile in the web user interface. \r\n\r\n  ![](images/test-api-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.2.\r\n\r\nSelect the **GET /shoppinglist/{department}** operation on the left. \r\n\r\n  ![](images/test-api-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.3.\r\n\r\nClick the **Try it** tab.\r\n\r\n  ![](images/test-api-3.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.4.\r\n\r\nEnter any **department** name (by now, we are not checking the department) such as **Candies** (A). Click **Send** (B).\r\n\r\n  ![](images/test-api-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 6.3.5.\r\n\r\nShow the **Response body**. Show the assigned name and description fields.\r\n\r\n  ![](images/test-api-5.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n\r\n### **7. Add Compute transformation**\r\n<details>\r\n<summary>7.1. Adding Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nThe Focus developers heard about ESQL language. Extended Structured Query Language (ESQL) is a programming language based on Structured Query Language (SQL) that is typically used to work with databases. ESQL is extended to access and manipulate data in messages and databases.\r\n\r\nThey would like to see how to use ESQL to transform and enrich messages using the Compute node.  Because of it, they decided to explore the Compute node transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.1.1.\r\n\r\nBack to the **getDepartment.subflow** (A), open again the Transformation menu and drag and drop a **Compute** node (B).\r\n\r\n  ![](images/add-compute-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.1.2.\r\n\r\nReadjust the connections of the *Input* and *Output* nodes to connect to the *Compute* node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Compute* node, and the *out* terminal of the *Compute* node will be wired to the *in* terminal of the *Output* node).\r\n\r\n  ![](images/add-compute-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.1.3.\r\n\r\nClick on the **Compute** node (A). On the Compute node's properties change the *Compute mode* to be “**LocalEnvironment and Message**” (B).\r\n\r\n  ![](images/add-compute-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.1.4.\r\n\r\n**Save** the subflow (you can safely ignore the red crosses on the Compute node - we will fix these up in the next step!).\r\n\r\n  ![](images/add-compute-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.2. Create Broker Schema</summary><br/>\r\n\r\n**Narration**\r\n\r\nTo simplify the demo, they decided to reuse a pre-created ESQL file.\r\n\r\nFirst, they need to create a Broker Schema to include the ESQL file. A broker schema is a symbol space that defines the scope of uniqueness of the names of resources defined within it.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.1.\r\n\r\nRight click the **ShoppingListAPI**  and choose **New > Broker Schema**.\r\n\r\n  ![](images/broker-schema-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.2.\r\n\r\nType **utils** as the Schema name (A) and click **Finish** (B).\r\n\r\n  ![](images/broker-schema-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 7.2.3.\r\n\r\nOn the *New Broker Schema* dialog, click **OK**.\r\n\r\n  ![](images/broker-schema-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.3. Copy ESQL file</summary><br/>\r\n\r\n**Narration**\r\n\r\nNext, Focus developers will copy the pre-created ESQL file to the broker schema folder.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.1.\r\n\r\nSwitch to the Resource perspective using the menu **Window > Perspective > Open Perspective > Other…**\r\n\r\n  ![](images/copy-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.2.\r\n\r\nChoose **Resource** (A) and click **Open** (B).\r\n\r\n  ![](images/copy-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.3.\r\n\r\nUsing the Project Explorer view, open the *HelperFiles* project and the **utils** folder, right click on the **Compute.esql** file (A) and select **Copy** (B).\r\n\r\n  ![](images/copy-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.4.\r\n\r\nOn the **ShoppingListAPI** project, right click on the **utils** folder, and select **Paste**.\r\n\r\n  ![](images/copy-esql-4.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.3.5.\r\n\r\nSwitch back to the *Integration Development* perspective using the **Window > Perspective > Open Perspective > Integration Development** menu.\r\n\r\n  ![](images/copy-esql-5.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.4. Update the ESQL module</summary><br/>\r\n\r\n**Narration**\r\n\r\nNow, they just need to update the Compute node to use the new ESQL file. They will use a specific module of the ESQL file: the getDepartment.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.1.\r\n\r\nReturn to the *getDepartment* subflow and click on **Compute** node again.\r\n\r\n  ![](images/update-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.2.\r\n\r\nOn the Compute node's properties, you need to update the *ESQL module* property. Click **Browse** button.\r\n\r\n  ![](images/update-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.3.\r\n\r\nSelect **{utils}:getDepartment_Compute** (A) and click **OK** (B).\r\n\r\n  ![](images/update-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.4.4.\r\n\r\n**Save** the subflow.\r\n\r\n  ![](images/update-esql-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.5. Review the ESQL</summary><br/>\r\n\r\n**Narration**\r\n\r\nLet's review the ESQL file. Focus developers can create and modify their ESQL code in the ESQL editor.\r\n\r\nThe ESQL code for each of your nodes is contained within a module in an ESQL file. Here they have a specific module for getDepartment operation.  The module is simple; just select the Item where the Department value equals the Department parameter.\r\n\r\nAll three items are hardcoded and created in the Initialise procedure. In a real scenario, this data should be retrieved from the Products database or Product system.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.1.\r\n\r\n**Double click** on the **Compute** node, to see the ESQL file.\r\n\r\n  ![](images/review-esql-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.2.\r\n\r\nShow the **getDepartment_Compute Module**.\r\n\r\n  ![](images/review-esql-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.3.\r\n\r\nScroll down and show the **Initialise Procedure**.\r\n\r\n  ![](images/review-esql-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.5.4.\r\n\r\n**Close** the ESQL file.\r\n\r\n  ![](images/review-esql-4.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>7.6. Test compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the new API. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using the three available departments: Candies, Snacks and Bakery.\r\n\r\nGreat, the subflow was invoked and our compute transformation created a response with our hard coded values. The Focus team verified how simple it is to use ESQL query language to implement message transformations.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-compute-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-compute-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.3.\r\n\r\nOn your browser, refresh the **Web User Interface** page.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), and **Try it** tab (C).\r\n\r\n  ![](images/test-compute-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.5.\r\n\r\nEnter a **department** name (it could be Candies, Snacks or Bakery)  (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments or try a different one to see the 404 Not Found message*.\r\n\r\n  ![](images/test-compute-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 7.6.6.\r\n\r\nShow the **Response** body.\r\n\r\n  ![](images/test-compute-6.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **8. Add Java transformation**\r\n<details>\r\n<summary>8.1. Adding Java Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nGreat, now the Focus Developers would like to see how to use Java code to tailor the behavior of their integration messages.\r\n\r\nThey want to learn how to use the JavaCompute node to examine the content of an input message, transform a message, and build new messages.\r\n\r\nBecause of this, they decided to explore the JavaCompute node.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.1.1.\r\n\r\nBack to the *getDepartment.subflow*, open again the *Transformation* menu and drag and drop a **JavaCompute** node.\r\n\r\n  ![](images/add-javacompute-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.1.2.\r\n\r\nReadjust the connections of the Input and output node to connect to the Java Compute node (the *out* terminal of the *Input* node will be wired to the *in* terminal of the *Java Compute* node, and the *out* terminal of the *Java Compute* node will be wired to the *in* terminal of the *Output* node).\r\n\r\n  ![](images/add-javacompute-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.2. Create Java Compute node class</summary><br/>\r\n\r\n**Narration**\r\n\r\nWith the App Connect toolkit, they can use the same tool that they use to create Integration flow to create Java code. Alternatively, if they want to share Java classes across multiple solutions, they can store Java code in a shared library and refer to that library from one or more applications that contain message flows with JavaCompute nodes\r\n\r\nHowever, the developers decided to try the Java Compute node class wizard to create template code to accelerate the development process. They selected the Modifying message class template, and in few seconds, they have a skeleton java code to manipulate and transform the integration message.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.1.\r\n\r\n*Double click* the **Java Compute** node.\r\n\r\n  ![](images/create-javaclass-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.2.\r\n\r\nOn the *New JavaCompute node class* dialog, accept the default values and click **Next**.\r\n\r\n  ![](images/create-javaclass-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.3.\r\n\r\nSelect **Modifying message class** template (A) and click **Next** (B).\r\n\r\n  ![](images/create-javaclass-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.4.\r\n\r\nOn the Java Settings view, accept the default values and click **Next**.\r\n\r\n  ![](images/create-javaclass-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 8.2.5.\r\n\r\nAccept the default Project name and click **Finish**.\r\n\r\n  ![](images/create-javaclass-5.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.3. Adding code</summary><br/>\r\n\r\n**Narration**\r\n\r\nFor this demo, they will only add a simple message code to create elements in the JSON message, for example add a new Apple Pie product item.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.1.\r\n\r\nOn the *GetDepartment_JavaCompute* class, **copy and paste the code below**, below the *Add user code below* comment.\r\n```\r\nMbElement outRoot = outMessage.getRootElement();\r\nMbElement outJsonRoot = outRoot.createElementAsLastChild(MbJSON.PARSER_NAME);\r\nMbElement outJsonData = outJsonRoot.createElementAsLastChild(MbElement.TYPE_NAME, MbJSON.DATA_ELEMENT_NAME, null);\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"name\", \"Apple Pie\");\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"department\", \"Bakery\");\r\noutJsonData.createElementAsLastChild(MbElement.TYPE_NAME_VALUE, \"description\", \"Request has been processed by Java Compute Node.\");\r\n```\r\n\r\n<br/>\r\n\r\n  ![](images/add-code-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.2.\r\n\r\nTo solve the imports issue, click on **Source > Organize Imports** menu.\r\n\r\n  ![](images/add-code-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.3.\r\n\r\nClick **File > Save All**.\r\n\r\n  ![](images/add-code-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.3.4.\r\n\r\n**Close** the Java class.\r\n\r\n  ![](images/add-code-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>8.4. Test Java Compute node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this moment, the Focus Integration experts are ready to test the new API using the JavaCompute node. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using the Bakery department only.\r\n\r\nGreat, the subflow was invoked and our java compute transformation created a response with our hard coded Apple Pie product. The Focus team verified how simple it is to use Java code to implement message transformation.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-java-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-java-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.3.\r\n\r\nOn your browser, **refresh** the *Web User Interface* page.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), **Try it** tab (C).\r\n\r\n  ![](images/test-java-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.5.\r\n\r\nEnter **Bakery** as **department** name (A). Click **Send** (B).\r\n\r\n  ![](images/test-java-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 8.4.6\r\n\r\nShow the **Response** body.\r\n\r\n  ![](images/test-java-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **9. Add Route**\r\n<details>\r\n<summary>9.1. Adding Route node</summary><br/>\r\n\r\n**Narration**\r\n\r\nFinally, they want to see how they can route messages through different paths in a message flow, based on the content of the message using a Route node.\r\n\r\nFocus Integration experts decided to add a route node to route messages through all different transformation nodes based on the department parameter.  The idea is to redirect to Mapping node only messages to Candies department, redirect to Compute node only messages to Snacks department and redirect to Java node only messages to Bakery department.\r\n\r\nLet's see how to do it!\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.1.1.\r\n\r\nBack to the getDepartment subflow, open the **Routing** menu and drag and drop a **Route** node.\r\n\r\n  ![](images/add-route-1.png)\r\n\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.1.2.\r\n\r\nDelete all existing wiring and connect the **Input** node to the new **Route** node.\r\n\r\n  ![](images/add-route-2.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.2. Renaming Match output terminal</summary><br/>\r\n\r\n**Narration**\r\n\r\nInitially, they need to rename the existing Match output terminal to mapping. And connect this terminal with the Mapping node.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.2.1.\r\n\r\nRight click on **Route** node (A) and select **Rename Output Terminal** (B).\r\n\r\n  ![](images/rename-terminal-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.2.2\r\n\r\n*On Select output terminal to rename* field, select **Match** (A). In the *Enter new name for the selected output terminal*, enter **mapping** (B). Then click **OK** (C).\r\n\r\n  ![](images/rename-terminal-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.2.3.\r\n\r\nWire the **mapping** output terminal from **Route** node to the **in** terminal of the **Mapping node**.\r\n\r\n  ![](images/rename-terminal-3.png)\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.3. Creating new output terminal</summary><br/>\r\n\r\n**Narration**\r\n\r\nSecond, they need to create two more output terminals to the compute and java transformation nodes. Connect these terminals to the Compute and JavaCompute nodes.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.3.1.\r\n\r\nRight click on **Route** node (A) and select **Add Output Terminal** (B).\r\n\r\n  ![](images/new-terminal-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.2.\r\n\r\nEnter **compute** as the name of the new output terminal (A) and click **OK** (B).\r\n\r\n  ![](images/new-terminal-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.3.\r\n\r\nRepeat the same steps to create the java terminal: Right click on **Route** node (A) and select **Add Output Terminal** (B).\r\n\r\n  ![](images/new-terminal-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.4.\r\n\r\nEnter **java** as the name of the new output terminal (A) and click **OK** (B).\r\n\r\n  ![](images/new-terminal-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.5.\r\n\r\nWire the **compute** output terminal from **Route** node to the **in** terminal of the **Compute** node.\r\n\r\n*Note: if you click the output terminals from Route, you will see a dialog to select the terminal that you want to wire.*\r\n\r\n  ![](images/new-terminal-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.3.6.\r\n\r\nRepeat the same steps to wire the **java** output terminal from **Route** node to the **in** terminal of the **Java Compute** node.\r\n\r\n*Note: if you click the output terminals from Route, you will see a dialog to select the terminal that you want to wire.*\r\n\r\n  ![](images/new-terminal-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.4. Adding filter patterns</summary><br/>\r\n\r\n**Narration**\r\n\r\nGreat! Now, they are ready to define the filter table. The Route node uses XPath expressions to control processing.\r\n\r\nFocus developers define the three XPath expressions, one for each transformation node.  The filter table map the XPath with the specific output terminal. The XPath is checking the department parameter value for each department.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.4.1.\r\n\r\nClick on the **Route** node.\r\n\r\n  ![](images/filter-patterns-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.2.\r\n\r\nOn the Filter table, click **Add** button.\r\n\r\n  ![](images/filter-patterns-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.3.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Candies\"** in the *Filter pattern* field (A) and select **mapping** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.4.\r\n\r\nClick **Add** button again.\r\n\r\n  ![](images/filter-patterns-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.5.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Snacks”** in the *Filter pattern* field (A) and select **compute** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.6.\r\n\r\nClick **Add** button again.\r\n\r\n  ![](images/filter-patterns-6.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.4.7.\r\n\r\nEnter **$LocalEnvironment/REST/Input/Parameters/department=\"Bakery”** in the *Filter pattern* field (A) and select **java** as the *Routing output terminal* (B). Then click **OK** (C).\r\n\r\n*Note: During the copy and paste you should have some issues with “ “,  because of that, we recommend typing the “ “ again in the Filter pattern field.*\r\n\r\n  ![](images/filter-patterns-7.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.5. Connecting nodes</summary><br/>\r\n\r\n**Narration**\r\n\r\nFinally, the Focus team connects all the nodes to finalize the flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 9.5.1.\r\n\r\nWire the *out* terminal of **Mapping**, **Compute** and **Java Compute** nodes to the *in* terminal of the **Output** node.\r\n\r\n  ![](images/route-connect-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.5.2.\r\n\r\nWire the *default* and *failure* terminal of **Route** node to the *in* terminal of the **Output** node.\r\n\r\n  ![](images/route-connect-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.5.3.\r\n\r\nClick **File > Save All**.\r\n\r\n  ![](images/route-connect-3.png)\r\n\r\n\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>9.6. Test Route node</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, the Focus Integration experts are ready to test the new API using the route node. They just need to redeploy the API and use the Web User Interface again to test it.\r\n\r\nNow, they will test using all three departments: Candies, Bakery and Snacks.\r\n\r\nGreat, the subflow was invoked and  the message is routed through all different transformation nodes based on the department parameter.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.1.\r\n\r\nRe-deploy the REST API, by dragging and dropping the **ShoppingListAPI** again from the Application Development view on to the **TEST_SERVER** Integration Server.\r\n\r\n  ![](images/test-route-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.2.\r\n\r\nOn the Progress Information dialog, click **Close**.\r\n\r\n  ![](images/test-route-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.3.\r\n\r\nOn your browser, **refresh** the **Web User Interface** page.\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.4.\r\n\r\nOpen again the **ShoppingListAPI** (A), **GET /shoppinglist/{department}** (B), **Try it** tab (C).\r\n\r\n  ![](images/test-java-4.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.5.\r\n\r\nEnter **Candies** (or Bakery, or Snacks) as **department** name (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments.*\r\n\r\n  ![](images/test-route-5.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 9.6.6.\r\n\r\nShow the **Response** body and show that each department is processed by different Transformation node (show the description field).\r\n\r\n  ![](images/test-route-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<br/><br/>\r\n\r\n### **10. Test on App Connect Enterprise**\r\n<details>\r\n<summary>10.1. Exporting BAR File</summary><br/>\r\n\r\n**Narration**\r\n\r\nAt this stage, the Focus team is ready to deploy their Integration flow in an App Connect Server. They just need to generate a BAR (broker archive) file. The App Connect Enterprise server uses BAR files to save compiled message flows, libraries, and other elements critical to the Integration flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.1.\r\n\r\nRight click the **ShoppingListAPI** (A) and choose **New > BAR file** (B).\r\n\r\n  ![](images/bar-file-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.2.\r\n\r\nOn the *New Bar file* dialog, type **shoppinglist** as the bar file name (A) and click **Finish** (B).\r\n\r\n  ![](images/bar-file-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.3.\r\n\r\nOn the *Prepare screen*, mark the **REST APIs** checkbox (A). Check **Compile and in-line resources** (B). Click **Build and Save** (C).\r\n\r\n  ![](images/bar-file-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.1.4.\r\n\r\nNow, a popup window displays *Operation completed successfully*. Click **OK**.\r\n\r\n  ![](images/bar-file-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.2. Accessing App Connect Enterprise environment</summary><br/>\r\n\r\n**Narration**\r\n\r\nIBM App Connect is an industry-leading integration solution that connects any of your applications and data, no matter where they reside. With hundreds of prebuilt connectors and customizable templates, App Connect helps users of all skill levels rapidly connect Software as a Service (SaaS) applications and build integration flows.\r\n\r\nFor this demo, Focus Corp is using a trial account of IBM App Connect Enterprise as a Service on AWS.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.2.1.\r\n\r\nIn your email inbox (that you used to create the App Connect trial account), search for **IBM SaaS** (A), open the ”**Your IBM App Connect trial is ready**” email (B).\r\n\r\n  ![](images/ace-access-1.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.2.\r\n\r\nNow, click the **Access trial** button.\r\n\r\n  ![](images/ace-access-2.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.3.\r\n\r\n**Log in** with your App Connect *username* and *password*.\r\n\r\n  ![](images/ace-access-3.png)\r\n\r\n<hr/><br/>\r\n\r\n\r\n**Action** &nbsp; 10.2.4\r\n\r\nUse the Instance switcher to change to the **Dashboard** instance.\r\n\r\n  ![](images/ace-access-4.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.3. Creating Integration server</summary><br/>\r\n\r\n**Narration**\r\n\r\nFocus integration experts begin in the IBM App Connect Dashboard. Here they can administer integration servers and integration runtimes, which are deployed from the BAR files mentioned earlier. They want to deploy the Integration flow defined in the previous steps.\r\n\r\nBecause they need to deploy a simple integration, let’s select with the Quick start integration type.\r\n\r\nNow they need to provide the BAR file. The BAR file contains all the resources that are needed to deploy an integration. The BAR file parameters will expose both the integration and its operations.\r\n\r\nThey can use the Configuration component to apply any customizations to the integration server when they deploy it. For their scenario, they don’t need to use the configuration package.\r\n\r\nNow, they need to define a name for their Integration server, for example shoppinglist.\r\n\r\nThat is it! After few minutes their server should be ready with their integration flow.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.1.\r\n\r\nClick **Deploy integrations**.\r\n\r\n  ![](images/inter-server-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.2.\r\n\r\nSelect **Quick start integration** option (A) and click **Next** (B).\r\n\r\n  ![](images/inter-server-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.3.\r\n\r\nClick to upload your BAR File. And select the **shoppinglist.bar** (A) file (it is in your workspace folder in a Bar Files directory). And click **Next** (B).\r\n\r\n  ![](images/inter-server-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.4.\r\n\r\nYou don’t need any Integration configuration, click **Next**.\r\n\r\n  ![](images/inter-server-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.5.\r\n\r\nEnter the Integration Server name as **shoppinglist** (A). Disable the option to **Force Flow Basic Auth** (B). Then click **Create** (C).\r\n\r\n  ![](images/inter-server-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.3.6.\r\n\r\nThe deployment process takes up to 5 minutes, **refresh** the browser to see the BAR file deployed and started.\r\n\r\n  ![](images/inter-server-6.png)\r\n\r\n***\r\n</details>\r\n\r\n<details>\r\n<summary>10.4. Testing the API</summary><br/>\r\n\r\n**Narration**\r\n\r\nTo finalize, the Focus Integration experts would like to test the new API in the App Connect Enterprise environment. They just need to open the Integration server and the API.\r\n\r\nNow, using the Try it capability, they will test using all three departments: Candies, Bakery and Snacks.\r\n\r\nGreat, the subflow was invoked and the message is routed through all different transformation nodes based on the department parameter.\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.1.\r\n\r\nClick the **shoppinglist** server icon.\r\n\r\n  ![](images/final-test-1.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.2.\r\n\r\nClick the **ShoppingListAPI** icon.\r\n\r\n  ![](images/final-test-2.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.3.\r\n\r\nIgnore the Open API Validation errors. Click on **GET /shoppinglist/{department}**,\r\n\r\n  ![](images/final-test-3.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.4.\r\n\r\nOpen the **Try it** tab.\r\n\r\n  ![](images/final-test-4.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.5.\r\n\r\nEnter **Candies** (or **Bakery**, or **Snacks**) as *department* name (A). Click **Send** (B).\r\n\r\n*Note: You are welcome to try any of the three departments.*\r\n\r\n  ![](images/final-test-5.png)\r\n\r\n<hr/><br/>\r\n\r\n**Action** &nbsp; 10.4.6.\r\n\r\nShow the **Response** body and show that each department is processed by different Transformation node (show the description field).\r\n\r\n  ![](images/final-test-6.png)\r\n\r\n***\r\n</details>\r\n\r\n\r\n### **Summary**\r\n\r\n<br/>\r\nLet’s summarize what Focus developers have done today. In this demo they: <br/>\r\n<ul>\r\n<li>Created Rest API using the App Connect Toolkit</li>\r\n<li>Created new API operation using the OpenAPI editor</li>\r\n<li>Implemented mapping transformation using the Mapping node</li>\r\n<li>Implemented compute transformation using ESQL query language and Compute node</li>\r\n<li>Implemented java transformation using Java code and JavaCompute node</li>\r\n<li>Implemented messaging routing using Route node</li>\r\n<li>Deployed and tested the Integration flow on IBM App Connect Enterprise as a Service on AWS</li>\r\n</ul><br/>\r\nIn this demo, Focus Integration experts learned how to build complex, multi-style integrations with support for multiple programming languages and fully integrated with source and pipeline management tools using the IBM App Connect toolkit.\r\n<br/><br/>\r\nThank you for attending today’s presentation.\r\n<br/>\r\n","fileAbsolutePath":"C:/Users/ruffa/Documents/GitHub/learninghub/src/pages/demos/ace-toolkit/demo-script.mdx"}}},"staticQueryHashes":["1364590287","137577622","137577622","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550","768070550"]}